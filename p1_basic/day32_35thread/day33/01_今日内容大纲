一, 上节课内容回顾

    1.Python的GIL锁
        - Python内置的一个全局解释器锁，锁的作用就是保证同一时刻一个进程中只有一个线程可以被cpu调度。
        为什么有这把GIL锁？
        答：Python语言的创始人在开发这门语言时，目的快速把语言开发出来，如果加上GIL锁（C语言加锁），切换时按照100条字节指令来进行线程间的切换。
                
    2. 进程和线程的区别？
        线程，cpu工作的最小单元。
        进程，为线程提供一个资源共享的空间。

        一个进程中默认是有一个主线程。
                
    3. 应用程序

    4. 编写多线程

    5. IO操作不占用CPU

    6. 进程和线程的使用准则：
        计算密集型：多进程
        IO密集型：多线程

    7. 线程创建的越多越好吗？不好
        线程之间进行切换时，要做上下文管理。

二, 作业讲解

三, 今日主要内容

    锁
        - 1次放1个
        - 1次放N个
        - 1次放动态N个
        - 1次所有放
        - threading.local
        - 生产者消费者模型

        1. 锁：Lock (1次放1个)
        
            线程安全，多线程操作时，内部会让所有线程排队处理。如：list/dict/Queue
            线程不安全 + 人 => 排队处理。
                
                
                需求：
                    a. 创建100个线程，在列表中追加8
                    b. 创建100个线程
                        v = []
                        锁
                        - 把自己添加到列表中。
                        - 再读取列表的最后一个。
                        解锁
                
                以后锁一个代码块：03 锁Lock.py
                        
        2. 锁：RLock (1次放1个),以后只用RLock。
                
        3. 锁：BoundedSemaphore（1次放N个）信号量  05 锁semaphore.py
                        
        4. 锁：Condition（1次方法x个）
                
        5. 锁：Event（1次放所有）
        
        总结：
            线程安全，列表和字典线程安全；
            为什么要加锁？
                - 非线程安全
                - 控制一段代码
        
        6. threading.local   08 threadinglocal.py
            作用：
                内部自动为每个线程维护一个空间（字典），用于当前存取属于自己的值。保证线程之间的数据隔离。
                {
                    线程ID: {...}
                    线程ID: {...}
                    线程ID: {...}
                    线程ID: {...}
                }

        7. 线程池 
        
        8. 生产者消费者模型 
            三部件：
                生产者
                    队列，先进先出
                    扩展：栈，后进先出
                消费者

            问：生产者消费者模型解决了什么问题？不用一直等待的问题。

重点总结：
        1. 锁         ***** 
        2. 线程安全    *****
        3. 线程池      *****
        4. threading.local ****
        5. 生成者消费者模型   ****